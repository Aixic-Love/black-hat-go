## 摘要

在本章要学会抓包和处理网络包。包处理用在很多地方，包括抓取明文身份验证凭证、更改包的应用程序功能，或者欺骗和毒害流量。还可以将其用于SYN扫描和通过SYN-floor保护进行端口扫描等。

我们将介绍谷歌的优秀的 gopacket 包，该包能够解码数据包并重新组装通信流。该包可以使用 Berkeley Packet Filter (BPF) 来过滤流量，也称为tcpdump语法；读写 *.pcap* 文件；检查各个层和数据；还有操作包。

我们将通过几个示例来演示如何识别设备、过滤结果和创建可以绕过 SYN-flood 保护的端口扫描器。

## 设置开发环境

在完成本章的代码之前，需要设置开发环境。首先，输入以下命令安装gopacket：

```shell
$ go get github.com/google/gopacket
```

现在，gopacket 依赖外部库和驱动程序绕过操作系统的协议栈。如果打算在 Linux 或 macOS 编译本章中的例子的话，需要安装  *libpcap-dev* 。使用大多数的包管理工具（如apt，yum，或 brew）来安装。下面使用 *apt* 来安装（其余两个安装过程类型）：

```shell
$ sudo apt-get install libpcap-dev
```

如果在Windows上编译运行本章中的例子，根据是否进行交叉编译，您有两个选项。如果不交叉编译的话设置开发环境相对简单点，但是在这种情况下，必须在 Windows 上创建 Go 开发环境，如果不想让另一个环境变得混乱，那么这个环境可能没有吸引力。目前，我们假设您有一个可以用来编译Windows二进制文件的工作环境。在该环境下需要安装 WinPcap 。从 *https://www.winpcap.org/* 下载免费版。

## 使用pcap子包识别设备

在抓包之前，必须确定可以监听的可用设备。可以使用 *gopacket/pcap* 子包中的 ` pcap.Find AllDevs() (ifs []Interface, err error)` 函数获取这些信息。清单8-1演示使用该函数列出所有可用的接口。

```go
package main

import (
	"fmt"
	"log"

	"github.com/google/gopacket/pcap"
)

func main() {
	devices, err := pcap.FindAllDevs()
	if err != nil {
		log.Panicln(err)
	}

	for _, device := range devices {
		fmt.Println(device.Name)
		for _, address := range device.Addresses {
			fmt.Printf("    IP:      %s\n", address.IP)
			fmt.Printf("    Netmask: %s\n", address.Netmask)
		}
	}
}
```

清单 8-1: 列出可用的网络设备 (https://github.com/blackhat-go/bhg/ch-8/identify/main.go/)

调用 `pcap.FindAllDevs()` 来枚举设备。然后循环遍历找到的设备。访问每个设备的属性，包括 *device.Name* 。通过属性 *Addresses* 也能访问IP地址，该属性是 *pcap.InterfaceAddress* 类型的切片。遍历循环他们的地址，将IP地址和掩码显示在屏幕上。

执行程序将产生类似于清单8-2的输出。

```shell
$ go run main.go 
enp0s5
	IP: 10.0.1.20
	Netmask: ffffff00
	IP: fe80::553a:14e7:92d2:114b 
	Netmask: ffffffffffffffff0000000000000000
any 
lo
	IP: 127.0.0.1
	Netmask: ff000000
	IP: ::1
	Netmask: ffffffffffffffffffffffffffffffff
```

清单8-2：显示可用网络接口的输出

输出列出了可用的网络接口—— `enp0s5，any 和 lo` ——也就是他们的IPv4和IPv6地址和掩码。每个系统上的输出可能与这些网络细节不同，但应该足够相似，以便您能够理解这些信息。 

## 实时抓包和过滤结果

既然您已经知道如何查询可用设备，那么就可以使用 `gopacket` 的特性来实时抓取数据包。在此过程中，还将使用**BPF** 语法过滤数据包集。**BPF** 能够限制抓取和显示的内容，以便只看相关的流量。通常根据协议和端口过滤流量。例如，可以创建一个过滤器来查看发送到端口80的所有TCP流量。还可以根据目标主机过滤流量。对BPF语法完整的论述超出了本书的范围。有关使用BPF的其他方法，请查看 *http://www.tcpdump.org/manpages/pcap-filter.7.html* 。

清单8-3显示了过滤流量的代码，以便只抓取发送到端口80或从端口80发送的TCP流量。

```go
package main

import (
	"fmt"
	"log"

	"github.com/google/gopacket"
	"github.com/google/gopacket/pcap"
)

var (
	iface    = "enp0s5"
	snaplen  = int32(1600)
	promisc  = false
	timeout  = pcap.BlockForever
	filter   = "tcp and port 80"
	devFound = false
)

func main() {
	devices, err := pcap.FindAllDevs()
	if err != nil {
		log.Panicln(err)
	}

	for _, device := range devices {
		if device.Name == iface {
			devFound = true
		}
	}
	if !devFound {
		log.Panicf("Device named '%s' does not exist\n", iface)
	}

	handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)
	if err != nil {
		log.Panicln(err)
	}
	defer handle.Close()

	if err := handle.SetBPFFilter(filter); err != nil {
		log.Panicln(err)
	}

	source := gopacket.NewPacketSource(handle, handle.LinkType())
	for packet := range source.Packets() {
		fmt.Println(packet)
	}
}
```

清单 8-3: 使用 BPF 过滤抓取特定的网络流量 (https://github.com/blackhat-go/bhg/ch-8/filter/main.go/)

代码首先定义设置抓包所需的几个变量。其中包括要抓取数据接口的名称，快照长度（每帧捕获的数据量），`promisc` 变量（表示是否运行承诺模式），和 `time-out`。还有BPF过滤器：`tcp and port 80`。这样就能只抓取符合这些条件的包。

在 `main()` 函数内，枚举可用的设备，遍历它们以确定所要的捕获接口是否存在于设备列表中。如果接口名不存在就 `panic`，说明这是无效的。