## 摘要

在本章要学会抓包和处理网络包。包处理用在很多地方，包括抓取明文身份验证凭证、更改包的应用程序功能，或者欺骗和毒害流量。还可以将其用于SYN扫描和通过SYN-floor保护进行端口扫描等。

我们将介绍谷歌的优秀的 gopacket 包，该包能够解码数据包并重新组装通信流。该包可以使用 Berkeley Packet Filter (BPF) 来过滤流量，也称为tcpdump语法；读写 *.pcap* 文件；检查各个层和数据；还有操作包。

我们将通过几个示例来演示如何识别设备、过滤结果和创建可以绕过 SYN-flood 保护的端口扫描器。

## 设置开发环境

在完成本章的代码之前，需要设置开发环境。首先，输入以下命令安装gopacket：

```shell
$ go get github.com/google/gopacket
```

现在，gopacket 依赖外部库和驱动程序绕过操作系统的协议栈。如果打算在 Linux 或 macOS 编译本章中的例子的话，需要安装  *libpcap-dev* 。使用大多数的包管理工具（如apt，yum，或 brew）来安装。下面使用 *apt* 来安装（其余两个安装过程类型）：

```shell
$ sudo apt-get install libpcap-dev
```

如果在Windows上编译运行本章中的例子，根据是否进行交叉编译，您有两个选项。如果不交叉编译的话设置开发环境相对简单点，但是在这种情况下，必须在 Windows 上创建 Go 开发环境，如果不想让另一个环境变得混乱，那么这个环境可能没有吸引力。目前，我们假设您有一个可以用来编译Windows二进制文件的工作环境。在该环境下需要安装 WinPcap 。从 *https://www.winpcap.org/* 下载免费版。

## 使用pcap子包识别设备

在抓包之前，必须确定可以监听的可用设备。可以使用 *gopacket/pcap* 子包中的 ` pcap.Find AllDevs() (ifs []Interface, err error)` 函数获取这些信息。清单8-1演示使用该函数列出所有可用的接口。

```go
package main

import (
	"fmt"
	"log"

	"github.com/google/gopacket/pcap"
)

func main() {
	devices, err := pcap.FindAllDevs()
	if err != nil {
		log.Panicln(err)
	}

	for _, device := range devices {
		fmt.Println(device.Name)
		for _, address := range device.Addresses {
			fmt.Printf("    IP:      %s\n", address.IP)
			fmt.Printf("    Netmask: %s\n", address.Netmask)
		}
	}
}
```

清单 8-1: 列出可用的网络设备 (https://github.com/blackhat-go/bhg/ch-8/identify/main.go/)

调用 `pcap.FindAllDevs()` 来枚举设备。然后循环遍历找到的设备。访问每个设备的属性，包括 *device.Name* 。通过属性 *Addresses* 也能访问IP地址，该属性是 *pcap.InterfaceAddress* 类型的切片。遍历循环他们的地址，将IP地址和掩码显示在屏幕上。

执行程序将产生类似于清单8-2的输出。

```shell
$ go run main.go 
enp0s5
	IP: 10.0.1.20
	Netmask: ffffff00
	IP: fe80::553a:14e7:92d2:114b 
	Netmask: ffffffffffffffff0000000000000000
any 
lo
	IP: 127.0.0.1
	Netmask: ff000000
	IP: ::1
	Netmask: ffffffffffffffffffffffffffffffff
```

清单8-2：显示可用网络接口的输出

输出列出了可用的网络接口—— `enp0s5，any 和 lo` ——也就是他们的IPv4和IPv6地址和掩码。每个系统上的输出可能与这些网络细节不同，但应该足够相似，以便您能够理解这些信息。 